---
apiVersion: v1
kind: Namespace
metadata:
  name: vso
---
# vault-helm-repo.yaml
apiVersion: source.toolkit.fluxcd.io/v1
kind: HelmRepository
metadata:
  name: hashicorp
  namespace: flux-system
spec:
  interval: 1h
  url: https://helm.releases.hashicorp.com
---
# Splitting CRDs into their own HelmRelease is the upgrade‑safe pattern
# It ensures CRDs are installed once and managed independently of the operator/app lifecycle, so uninstalling or upgrading the chart won’t accidentally remove or overwrite them.
# Lifecycle safety: CRDs persist even if you uninstall the app release.
# GitOps clarity: you can roll back or upgrade the app without risking CRD mismatches.
# Note: There is only one chart (vault-secrets-operator) with CRDs are bundled inside it.
# Split into separate HelmReleases for lifecycle safety.
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: vault-secrets-operator-crds
  namespace: vso
spec:
  interval: 10m
  chart:
    spec:
      chart: vault-secrets-operator
      version: 0.10.0   # adjust to desired version
      sourceRef:
        kind: HelmRepository
        name: hashicorp
        namespace: flux-system
  install:
    crds: Create
  upgrade:
    crds: CreateReplace
  values:
    # disable everything except CRDs
    enabled: false
---
# vault-secrets-operator
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: vault-secrets-operator
  namespace: vso
spec:
  interval: 10m
  chart:
    spec:
      chart: vault-secrets-operator
      version: 0.10.0
      sourceRef:
        kind: HelmRepository
        name: hashicorp
        namespace: flux-system
  install:
    crds: Skip
  upgrade:
    crds: Skip
  values:
    replicaCount: 1
    # Configures the default VaultConnection CR which will be used by resources
    # if they do not specify a VaultConnection reference. The name is 'default' and will
    # always be installed in the same namespace as the operator.
    # NOTE:
    # * It is strongly recommended to deploy the vault secrets operator in a secure Vault environment
    #   which includes a configuration utilizing TLS and installing Vault into its own restricted namespace.
    defaultVaultConnection:
      # toggles the deployment of the VaultAuthMethod CR

      enabled: false # we will create our own VaultAuth below
---
apiVersion: secrets.hashicorp.com/v1beta1
kind: VaultConnection
metadata:
  name: vault-conn
  namespace: vso
spec:
  address: https://vault.leclub.org.uk # Address of the Vault Server
  
  # replaces .spec.tls.insecureSkipVerify
  skipTLSVerify: true

  # If you want to use a CA instead of skipTLSVerify:
  # caCertSecretRef:
  #   name: vault-ca
  #   key: ca.crt
---
# Vault’s Kubernetes auth method requires: 
#     a ServiceAccount
#     a ClusterRoleBinding granting system:auth-delegator
#     a Vault role that trusts that ServiceAccount
#
# Create a service account for Vault
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-sa
  namespace: vso
# explicitly enable token mounting
automountServiceAccountToken: true
---
# Create a ClusterRoleBinding for the service account granting system:auth-delegator
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-auth-binding
subjects:
  - kind: ServiceAccount
    name: vault-sa
    namespace: vso
roleRef:
  kind: ClusterRole
  name: system:auth-delegator
  apiGroup: rbac.authorization.k8s.io
---
# Note:
# You do NOT need to create a ServiceAccount token Secret manually anymore.
# Kubernetes will automatically create the token Secret for the ServiceAccount 
# if the ServiceAccount is referenced by a Vault Kubernetes auth method.
# IMPORTANT:
# Even though Kubernetes 1.24+ normally does not require this,
# SUSE K3s still requires a token Secret for external TokenRequest consumers like VSO
apiVersion: v1
kind: Secret
metadata:
  name: vault-sa-token
  namespace: vso
  annotations:
    kubernetes.io/service-account.name: vault-sa
type: kubernetes.io/service-account-token